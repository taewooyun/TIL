### mutex를 사용할 때 주의해야할 점
아주 좋은 질문이야.
**“mutex를 쓸 줄 안다”와 “제대로 쓴다”의 차이**가 여기서 갈려 👍
로그 예제 기준으로 **실무에서 꼭 알아야 할 주의사항**만 정리해줄게.

---

## 1️⃣ lock / unlock 직접 쓰지 말 것 ❌

### ❌ 위험한 코드

```cpp
logMutex.lock();
doSomething();
if (error) return;   // unlock 안 됨 → 데드락
logMutex.unlock();
```

### ⭕ 안전한 방식

```cpp
std::lock_guard<std::mutex> lock(logMutex);
doSomething();
```

📌 **RAII 무조건 사용**

---

## 2️⃣ 임계 영역은 최소한으로 ⚠️

### ❌ 나쁜 예

```cpp
std::lock_guard<std::mutex> lock(logMutex);
heavyCalculation();
writeLog();
```

### ⭕ 좋은 예

```cpp
heavyCalculation();

{
    std::lock_guard<std::mutex> lock(logMutex);
    writeLog();
}
```

👉 **lock 잡고 있는 시간 = 짧을수록 좋음**

---

## 3️⃣ mutex 안에서 또 다른 mutex 잡지 말 것 (중요)

### ❌ 데드락 위험

```cpp
lock(mutexA);
lock(mutexB);
```

다른 스레드:

```cpp
lock(mutexB);
lock(mutexA);
```

👉 **교착 상태(Deadlock)**

### ⭕ 규칙

* mutex 순서 고정
* 가능하면 **하나만 사용**

---

## 4️⃣ 로그 안에서 로그 찍지 말 것 ❌

### ❌ 치명적 실수

```cpp
std::lock_guard<std::mutex> lock(logMutex);
logMessage("에러 발생");  // 자기 자신 호출 → 데드락
```

### ⭕ 규칙

* mutex 보호 함수 안에서는
* 같은 로그 함수 호출 금지

---

## 5️⃣ 예외 발생 가능 코드 주의 ⚠️

* 파일 I/O
* filesystem
* 메모리 할당

👉 `lock_guard` 쓰면 예외 나도 자동 unlock
👉 그래서 **lock_guard 필수**

---

## 6️⃣ static / 전역 mutex 하나로 충분한지 생각

### 로그의 경우

```cpp
static std::mutex logMutex; // OK
```

### 데이터 구조 보호

* 객체마다 mutex 필요할 수도 있음

👉 **자원 단위로 mutex 설계**

---

## 7️⃣ 성능에 집착하지 말 것 (초반엔)

* mutex 비용 << 파일 IO 비용
* 로그는 디버깅용

👉 **안전성이 먼저**

---

## 8️⃣ 멀티스레드 아닌데 mutex 쓰는 건?

* 문제 없음
* 오버헤드 미미
* 미래 대비

---

## 9️⃣ 절대 하지 말 것 요약 ❌

| 금지                | 이유        |
| ----------------- | --------- |
| lock/unlock 직접 사용 | unlock 누락 |
| mutex 중첩          | 데드락       |
| 긴 작업 중 lock 유지    | 성능 저하     |
| 로그 안에서 로그         | 무한 대기     |

---

## 🔥 한 문장 요약 (면접용)

> “mutex는 RAII로 관리하고, 임계 영역을 최소화하며,
> 중첩 잠금과 재귀 호출을 피해야 합니다.”

---

이제 이 정도면
👉 **“mutex 왜 쓰고, 어떻게 쓰고, 언제 위험한지”**
전부 설명 가능해 👍
