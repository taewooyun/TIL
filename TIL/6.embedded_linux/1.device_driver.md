# 리눅스 디바이스 드라이버

## 임시 이름:
리눅스의 개발 요소
### 내용:
1. bootloader(u-boot)
2. device tree(overlay)
3. kernel(driver)
4. rootfilesystem(buildroot)

### 키워드:

---
## 임시 이름:
리눅스의 장점
### 요약:
리눅스는 **네트워크·성능·안정성·확장성·자율성**을 동시에 만족하는 OS이기 때문에 서버, 클라우드, 네트워크 장비, 임베디드까지 지배하고 있다.
### 키워드

---
## 임시 이름:
콘솔과 터미널
### 내용:
콘솔 : 물리 TTY
/dev/tty1
uart는 ttyS0를 쓴다
...
터미널 : 가상 TTY
/dev/pts/0
...
현재 터미널
/dev/tty
### 키워드

---
## 임시 이름:
리눅스의 실행환경
### 요약:
리눅스 포팅이란 특정 보드에 리눅스를 실행시키기 위해 각각의 하드웨어에 작업하는 일련의 과정을 일컫는다
### 내용:
1. CPU
    porting : X (manufacturer)
2. memory
    porting : 데이터시트를 참고, timing을 찾아서 커널에 맞춰줘야한다
3. console
    stdin, stdout, stderr
    일반적으로 구성이 되어 있지만 uart의 경우에는 필요할 수 있다
4. io (device/peripherals)
    장치 타입의 종류 마다 드라이버를 작성하는 방법이 다르다
    char  
    block 
    ...
    porting : driver 작성


---
## 임시 이름:
리눅스 커널 소스트리
### 내용:
주요 커널 소스
arch : 아키텍쳐 종속 코드
documentation : 커널 소스 문서
drivers : 디바이스 드라이버
include : 커널 헤더 파일들
init : 커널 부트와 초기화 관련
  - start_kernel : 커널이 시작할 때 최초로 실행되는 c 함수
ipc : 프로세스간 통신 코드
lib : 유틸리티 루틴


---
## 임시 이름:
드라이버 작성 시 고려 사항
### 요약:
실행영역 커널영역
  - 드라이버는 커널의 부분
  - 오작동 시 치명적 피해

콜백함수제공

커널기능이용
  - 메모리 할당
  - 인터럽트
  - 동기화

제작형태  결정
  - 커널형태
  - 모듈형태

---
## 임시 이름:
드라이버 소스 로케이션
### 한 줄 요약:

### 내용:
tree : kernel tree

in-tree
  /drivers/...
  커널 소스 트리 내에 hello.c
ex-tree
  /home/user/...

### 키워드:

### 질문:


---
## 임시 이름:
드라이버 제작 형태
### 요약:
dht11.c -> dht11.o ->
1. vmlinux : 커널 포함 형태
  - zImage에 내장
2. dht11.ko (*선호) : 커널 모듈에 탑재
  - kernel object
### 키워드:


---
## 임시 이름:
커널 소스
### 요약:
`/boot` 
1. kernel.org
2. linux-x.x.x.gz
  - kernel
    - vmlinux -> Image -> zImage (kernel8.img)
  - driverSource
    - `/lib/modules/6.1.21-v8+/kernel/drivers/`
  - divice tree
    - bcm2711-rpi-4-b.dtb
### 키워드:
start.elf : bootloader

---

## 임시 이름:
디바이스의 종류
### 요약:
문자 디바이스
- 바이트 단위 입출력
- /dev의 node를 통해 접근
    - /dev/console
    - /dev/ttyS0
- 주로 순차 참조
- keyboard, mouse, serial, modem, video,...

블록 디바이스
- 블록 단위 입출력 (버퍼 사용)
- /dev의 node를 통해 접근
    - /dev/sda
- 순차 및 랜덤 참조
- hard disk, cd-rom, usb disk,...

소스코드 위치
- drivers/char
- drivers/block
- drivers/misc
- drivers/input
- drivers/video
- drivers/i2c
- drivers/iio

### 키워드:

---

## 임시 이름:
유저 영역에서 커널 영역의 자료 참조
### 요약:
`/proc` : 커널이 오픈한 정보를 인터렉티브하게 열람하는 곳
- /cpuinfo : cpu의 정보
- /meminfo : 메모리 정보
- /proc : 커널의 명령행 인자
`/sys`  : 드라이버가 오픈한 정보를 인터렉티브하게 열람하는 곳
- /firmware
- bus
- device
- class

### 키워드:

---

## 임시 이름:
리눅스 커널 설치 및 빌드
### 요약:
upstream : 원본 저장소
[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags]

fetch : 원격 저장소에서 소스 코드를 가져오는 단계
unpack : 압축된 소스를 해제하는 단계
patch : 소스 코드에 수정 사항을 적용
configure : 커널 빌드 옵션을 설정하는 단계
- `$ apt install libncurses-dev flex bison`
- `$ make menuconfig`
- `$ export KERNEL=kernel8`
- `$ export ARCH=arm64`
`.config`에 설정이 반영된다
makefile
- obj-$(CONFIG_DHT11) += dht11.o
    - obj-m -> xxx.ko
    - obj-y -> vmlinux -> zImage
    - obj-  -> no compile

compile
link
install
exec

### 키워드:

---

## 임시 이름:
리눅스 디바이스 트리 구조
### 요약:
1. source files
    - .dts     (.c)
    - .dtsi    (.h)
2. complier
    - dtc
3. binaries
    - .dtb     (device tree blob)
    - .dtbo    (dtb overlay)


### 키워드:

---

## 임시 이름:
모듈 빌드 설정 및 실행
### 요약:
`/lib/modules/???`

`$ insmod .ko` : 모듈 삽입
`$ lsmod`      : 현재 탑재 된 모듈
`$ rmmod`      : 모듈 삭제

`printk()`     : 기본적으로 콘솔에 출력
- `$ cat /var/log/messages`
`$ dmesg`      : 모듈 메세지 출력
- `-c`         : 출력 후 클리어

### 키워드:

---

## 임시 이름:
리눅스 포팅의 흐름
### 요약:
1. bootloader(u-boot, ...) : start.elf를 호출해서 시작
2. device tree(overlay) : .dtb 파일
3. kernel(driver) : 드라이버 패치
4. rootfile system(buildroot, yocto, ...) : 루트 파일 시스템을 구축


### 키워드:

---

## 임시 이름:
모듈의 기본 형태 `module.h`
### 요약:
초기화 등록 함수
초기화 해제 함수
등록 매크로 제공(`linux/init.h`)

module_platform_driver()
module_i2c_driver()
module_usb_driver()
module_spi_driver()
module_pci_driver()

모듈 라이선스가 반드시 필요
`MODULE_LICENSE("GPL")`
- 경고 메세지, 기능에 제약

### 키워드:

---

## 임시 이름:
모듈 드라이버 매개변수 전달
### 요약:
`$ insmod .ko param=arg`
- `charp`
- `module_param_array`

### 키워드:

---

## 임시 이름:
커널 심볼 내보내기
### 요약:
주어진 심볼을 전역으로 내보내 다른 드라이버에서도 사용하도록 함

```bash
cat /proc/kallsyms | grep expo_
ffffffec1f377020 r __kstrtab_expo_vars  [51_dev]
ffffffec1f37702a r __kstrtabns_expo_vars        [51_dev]
ffffffec1f37700c r __ksymtab_expo_vars  [51_dev]
ffffffec1f37702b r __kstrtab_expo_func  [51_dev]
ffffffec1f377035 r __kstrtabns_expo_func        [51_dev]
ffffffec1f377000 r __ksymtab_expo_func  [51_dev]
ffffffec1f37701c r __crc_expo_vars      [51_dev]
ffffffec1f377018 r __crc_expo_func      [51_dev]
ffffffec1f376000 T expo_func    [51_dev]
ffffffec1f378010 D expo_vars    [51_dev]
```

```bash
cat /lib/modules/6.1.21-v8+/modules.dep | grep dht11
kernel/drivers/iio/humidity/dht11.ko.xz: kernel/drivers/iio/industrialio.ko.xz
```
- 의존관계가 저장됨


### 키워드:

---

## 임시 이름:
캐릭터 디바이스의 특징
### 요약:
간헐적 데이터
바이트 데이터 발생

### 키워드:

---

## 임시 이름:
Charactor device / Block device 를 식별하는 방법
### 요약:
장치번호 
장치 번호의 타입
- dev_t @ linux/types.h
    - Major(12bit), Minor(20bits)
장치 번호의 구성
- Major 번호
    - 디바이스 드라이버를 실행시킬 때 디바이스를 찾아가기 위해 디바이스트리가 존재한다
- Minor 번호
    - 동종 장치의 개별 식별을 위해 사용되는 번호
장치 번호 구성용 매크로
- `MAJOR(dev_t dev)` : 주 번호 추출
- `MINOR(dev_t dev)` : 부 번호 추출
- `MKDEV(int major, int minor)` : 장치 번호 생성
등록 장치 번호 확인
`# cat /proc/devices`

장치 번호를 지정하는 방법
- Documentation/devices.txt 참조
- `# cat /proc/devices`로 현황파악
- 장치에 예약된 번호를 사용하거나 새로운 장치번호를 부여 (~ 254) or (255 ~ 512)
- `register_chrdev_region()` 를 이용하여 직접 지정
    - `int register_chrdev_region(dev_t first, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- 비어있는 번호를 자동으로 할당
- 254번 부터 큰값부터 할당
- `alloc_chrdev_region()` 사용
    - `int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)`

장치 번호를 할당하는 방법
- `unregister_chrdev_region()` 사용
    - `void unregister_chrdev_region(dev_t first, unsigned int count)`

### 키워드:

---

## 임시 이름:
문자 장치 표현
### 요약:
`linux/cdev.h`
cdev 구조체를 사용하여 캐릭터 디바이스를 표현한다

`cdev_init()`
`void cdev_add(struct cdev *cdev, dev_t num, unsigned int count)`
`void cdev_del(struct cdev *cdev)`

### 키워드:

---

## 임시 이름:
장치 파일의 생성 방법
### 요약:
1. `# mknod /dev/name type major minor`
2. `int mknod(const char *pathname, mode_t mode, dev_t dev)`
3. `struct device *device_create()`

### 키워드:

---

## 임시 이름:
드라이버 컨텍스트
### 요약:
어떤 경로로 드라이버를 찾아왔는가

1. TOP(application) --> driver
- 프로세스 컨텍스트
- 시스템 콜에 의해 실행
    - 유저 영역에서 호출한 open에 해당하는 함수를 구조체를 통하여 드라이버에 구현해야 한다
        - .open      = my_open,
        - .release   = my_release
2. Bottom(hardware) --> driver
- 인터럽트 컨텍스트
- 인터럽트에 의해 실행


### 키워드:

---




# 1/2 추가 필요



캐릭터 드라이버
file operation
.open
.release
.read
.wirte
.ioctl
callback function




커널에서 동적 메모리를 할당하기
커널 서비스
kmalloc
GFP_KERNEL : process context, blocked
GFP_ATOMIC : interrupt context, wait

메모리관리
버디 할당자
2^N page 단위로 할당
슬랩 할당자
kmem_cache에 정의한 cache

kmalloc() : 연속적으로 할당
- kfree()
vmalloc() : 비연속
- vfree()





인터럽트 처리

예외처리
- 아키텍쳐마다 다름
- 익셉션 벡터 테이블 -> 인터럽트 벡터 테이블 -> 인터럽트 처리 루틴

ISR 구현을 해본건가


dtoveraly






---

## 임시 이름:
TOP HALF와 BOTTOM HALF
### 요약:
io의 버퍼가 다 차기 전에 driver 버퍼에 인터럽트로 올리는 작업

Top half
urgent : by isr


Bottom half
deferrable : by kthread(wroker thread)
- softirq
    - 정적 생성
    - 성능 우수
    - 비권장
- tasklet
    - 동적 생성
    - softirq를 기반으로 발전 시킨 형태
    - 같은 타입의 태스크릿들이 동시에 실행 될 수는 없음
- workqueue
    - 우리가 필요한 bottom half는 프로세스적인 특징들이 필요하다
- threaded irq

### 키워드:

---

## 임시 이름:
Workqueue의 특징

### 요약:
커널 쓰레드를 생성하여 BH를 구현한다
프로세스 컨텍스트의 특징을 모두 갖는다
- 선점이 기능
- 인터럽트도 허용
- 휴면, 많은 메모리 할당, 세마포어 획득, 블록킹 I/O
글로벌 워크큐와 커스텀 워크큐 방식이 있다


### 키워드:

---

## 임시 이름:
kworker

### 요약:
deferred work를 담당하는 일꾼 커널 스레드들
워크큐에 등록된 타스크들을 하나씩 꺼내어 비동기적으로 처리한다

역할
- 커널이 인터럽트 핸들러나 기타 중요한 커널 스레드가 오랜 시간 동안 블록되는 것을 방지하기 위해, 시간이 오래 걸리거나 즉각적으로 처리할 필요가 없는 작업을 유크큐에 등록
- 워크큐에 쌓인 작업들을 하나씩 꺼내서 순차적으로 처리한다
- 이는 bh메커니즘의 한 종류, 커널 응답성을 유지하고 시스템의 안정성을 높이는데 중요한 역할을 담당
- ex) 파일 시스템 동기화, 장치 드라이버의 지연 작업, 메모리 관리 등 커널의 중요한 기능

생성
- schedule_work()/queue_work함수를 호출하여 작업을 워크큐에 추가할 때 커널은 내부적으로  kworker 스레드를 깨우거나

### 키워드:


---

## 임시 이름:
workqueue의 사용법

### 요약:
global
커널이 제공하여 이미 존재하는 workqueue를 사용하여 work만 넣어주면 됨

`struct work_struct work`
- 워크 선언
`INIT_WORK(&work, void (*function)(struct work_struct *))`
- 선언된 워크 큐 구조체 변수를 초기화하는 매크로
`DECLARE_WORK(wrok, void (*function)(struct work_struct *))`
- 선언과 함께 초기화

`int schedule_work(?)`
- 워커 스레드를 스케줄
`int schedule_dlayed_work(?)`
- 워커 스레드를 delay(jiffies) 만큼 지연시켜 스케줄
`int schedule_work_on(?)`
- 지정된 CPU에 스케줄
`int schedule_delayed_work_on(?)`
- 지정된 CPU에 지연시켜 스케줄

custom
workqueue와 work 둘 다 만들어야 함
`struct workqueue_struct *create_workqueue(const char *name)`
- 워크 큐를 생성하는 매크로
`void destry_workqueue(struct workqueue_struct *queue)`
- 워크 큐를 제거하는 매크로
`alloc_workqueue(fmt, flags, max_active)`
- flags의 종류
    - WQ_UNBOUND : ?
    - WQ_FREEZABLE : ?
    - HIGHPRI : ?
    - CPU_INTENSIVE : ?

`int queue_work(?)`
- 커스텀 워크를 워크 큐에 스케줄
`int queue_work_on(?)`
`int queue_delayed_work(?)`
`int queue_delayed_work_on(?)`

> 실습 2203, 2205

### 키워드:

---

## 임시 이름:
threaded irq의 사용법

### 요약:
IRQ 처리를 irq 핸들러와 kernel 스레드로 나누어 시간차로 처리하는 방식

작동 방식
- `request_threaded_irq()` 사용 -> Bottom Half를 kernel thread로 등록
- 인터럽트 발생

장점
- 높은 시스템 응답성
- 단순한 코드 작성
- IRQ 공유 용이성
- tasklet과 workqueue에 비해 스케줄링 우선순위를 세밀하게 제어할 수 있다
- 디버깅 용이성


> 실습 2206

### 키워드:

---

## 임시 이름:
memory mapped i/o macro
### 요약:
read macro

write macro
- 데이터를 쓰는 함수
- 스트림 데이터를 쓰는 함수




### 키워드:

---

## 임시 이름:
유저와 커널 공간간에 데이터 전송

### 요약:
`#include<asm/uaccess.h>`
`long access_ok` : 사용자 메모리 공간 유효성ㄱ ㅓㅁ사
`int copy_to_user` : 커널 메모리 블록 데이터를 사용자 메모리 블록 데이터에 쓰기
`int copy_from_user` : 사용자 메모리 블록 데이터를 커널 메모리 블록 데이터에 쓰기
`int get_user` : 사용자 공간의 데이터 읽기, 변수 x의 바이트 수 만큼
`int put_user` : 커널 변수 값을 사용자 공간에 쓰기, 변수 x의 바이트 수 만큼


### 키워드:

---

## 임시 이름:
ARM I/O memory

### 요약:
ARM io memory : SFR(Special Function Register)
`#include<asm/io.h>`

`void *iormap`
`void *iounrmap`

메모리 매핑
`mmap()` : UserSpace 

`ioremap()` : KernelSpace



`remap_pfn_`

> 실습 2308/2311

### 키워드:

---

## 임시 이름:
ssd1306 사용해보기

### 요약:
i2c 방식과 spi 방식이 존재



### 키워드:


---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---

## 임시 이름:

### 요약:

### 키워드:

---